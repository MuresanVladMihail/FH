# Test modulo optimization (power-of-2 vs generic)
fn main() {
    # Power-of-2 modulo (should use bitwise AND)
    printf("Testing power-of-2 modulo:\n");
    printf("10 %% 2 = %d (expected 0)\n", 10 % 2);
    printf("11 %% 2 = %d (expected 1)\n", 11 % 2);
    printf("10 %% 4 = %d (expected 2)\n", 10 % 4);
    printf("17 %% 8 = %d (expected 1)\n", 17 % 8);
    printf("100 %% 16 = %d (expected 4)\n", 100 % 16);

    # Non-power-of-2 modulo (generic path)
    printf("\nTesting non-power-of-2 modulo:\n");
    printf("10 %% 3 = %d (expected 1)\n", 10 % 3);
    printf("17 %% 5 = %d (expected 2)\n", 17 % 5);
    printf("100 %% 7 = %d (expected 2)\n", 100 % 7);

    # Benchmark: modulo in loop
    let sum = 0;
    let start = os_time();
    for (let i = 0; i < 1000000; i++) {
        sum = sum + (i % 8);  # Power-of-2 (fast path)
    }
    let end = os_time();
    printf("\nPower-of-2 mod: sum=%d in %d ms\n", sum, os_difftime(start, end));

    sum = 0;
    start = os_time();
    for (let i = 0; i < 1000000; i++) {
        sum = sum + (i % 7);  # Non-power-of-2 (generic)
    }
    end = os_time();
    printf("Generic mod: sum=%d in %d ms\n", sum, os_difftime(start, end));
}
