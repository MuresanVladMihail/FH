# Test closure variable capture
fn make_adder(x) {
    return fn(y) {
        return x + y;
    };
}

fn make_counter(start) {
    let count = start;
    return fn() {
        count = count + 1;
        return count;
    };
}

fn make_multiplier(factor) {
    return fn(n) {
        return n * factor;
    };
}

fn main() {
    # Test basic closure
    let add5 = make_adder(5);
    assert(add5(3) == 8);
    assert(add5(10) == 15);

    # Test multiple closures with different captured values
    let add10 = make_adder(10);
    assert(add10(5) == 15);
    assert(add5(5) == 10);  # add5 still works

    # Test mutable captured variable
    let counter = make_counter(0);
    assert(counter() == 1);
    assert(counter() == 2);
    assert(counter() == 3);

    # Test another counter with different start
    let counter2 = make_counter(10);
    assert(counter2() == 11);
    assert(counter() == 4);  # Original counter unchanged

    # Test closure with multiplication
    let times2 = make_multiplier(2);
    let times10 = make_multiplier(10);
    assert(times2(5) == 10);
    assert(times10(5) == 50);

    print("ok\n");
}
